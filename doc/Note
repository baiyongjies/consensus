分布式异步系统一致性问题：
环境：
每个节点运行一个不断循环的主线程，和可能有多个并发执行的消息处理线程，主线程需要执行添加缓存区块到区块链数据库并更新变量、产生生区块、发布区块、根据缓存中的生区块发送消息给对应的管家节点，而消息处理线程则需要将接收到的生区块和新发布的区块存进缓存中。
考虑极限情况下程序可能产生的问题：
在这样的情况下，A执行一次主循环，发布高度为h的区块，但很可能A并不能及时收到并处理该区块，导致A将可能第二次执行该发布区块的操作，由于每次执行该操作都会从签名池取出过半数的签名放进区块中，很有可能A在第一次发布区块时还没收到所有的委员的签名，而第二次发布区块时又收到新接收的签名，导致两次发布的区块不一致。而接收新区块的逻辑是每接收到一个高度为h的区块都会替换掉之前的区块，因此如果部分节点更新区块比较快，就可能更新完第一次发布的区块，再接收到第二次发布的区块，而部分更新区块较慢的节点则可能接收到第二次发布的区块后才更新区块，最后区块链数据的不一致性，反映出来的情况就是部分节点在接收到其他节点发送的新发布的生区块时验证前一个区块的区块头hash不正确。
这个问题的解决办法很多，下面对于几种容易实现的方法进行讨论：
1.首先考虑在接收新区块时不把旧区块替换为新区块，这样每次更新区块都是对第一次接收到的区块进行更新。但是这显然是不合理的，因为是异步通信，第二次发布的区块有可能比第一次发布的区块早到达，还是有可能造成数据不一致的问题。
2.区块执行完一次发布区块的操作后，就跳转到一个结束状态，这样就不会第二次执行发布区块的操作。一般来说TCP通信能确保消息发送到其他节点，不会造成消息丢失的问题，因此也不需要重传，这样操作是没有问题的。但如果有发生消息丢失的可能该方法则不可行。
3.发布区块时，使用一个全局变量保存该区块，第二次执行该发布操作时，直接从该变量获取区块并发布。该操作是肯定没有问题的。

综上，第二种方法是最简单的方法，但是由于我不是完全确定消息丢失在任何情况下都不会发生，因此还是使用第三种方案解决该问题。


标识查询服务逻辑过程：
任意节点接收到NDN相关请求后，将其转发给当前值班管家和值班管家的下一编号管家。管家节点接收到NDN请求后将其存放在交易池中，当一个管家节点成为值班管家时，从交易池中取出交易封装到预区块中，并将预区块发送给所有委员请求签名，而被取出的交易会被从交易池中删除。委员节点在接收到预区块时对预区块进行验证，验证通过则发送区块签名给值班管家，否则发送验证失败消息给管家节点。值班管家节点在接收到委员节点的签名时会将其存放进签名池中，在接收到过半数的委员签名时，值班管家则将签名存放进区块中并发布区块。反之如果接收到过半数的验证失败消息则重新产生预区块并重新请求签名。

新增的两个功能点：
1.在交易池中取出交易的同时在交易池中删除该交易，使得当交易池中存在错误交易导致产生区块失败时重新产生的区块不再包含这些错误交易。
2.增加预区块错误反馈机制，当区块验证失败时委员发送错误消息给值班管家，使得值班管家可以及时知道该区块不合法从而迅速产生下一个区块，加快了区块重传速度，同时重新产生了区块也排除了旧区块中的错误。
